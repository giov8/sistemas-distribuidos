<!DOCTYPE html>
<html lang=pt-br>
<body background="background3.jpeg">
<style>
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}
</style>
<center>
<h1 style="font-family:verdana;">TRABALHO 3 - BEST-EFFORT BROADCAST SOBRE VCUBE V1 (Modificação)  </h1>
<h2 style="font-family:verdana;">Sistemas Distribuídos ERE2 2020</h2>
<p style="font-family:verdana;">Giovani G. Marciniak - ggm18@inf.ufpr.br - GRR20182981
<br><b>Professor:</b> Elias Procópio Duarte Jr.</p>
</center>

<h2 style="font-family:verdana;">Introdução</h2>
<p style="font-family:verdana;">Este trabalho visa a implementação do algortimo Best-Effort Broadcast sobre a versão 1 (original) do algoritmo distribuído VCube, no ambiente de simulaçao SMPL. O algortimo VCUBE faz o diagnóstico em um sistema distribuído realizando testes em forma de "hipercubo", com a ajuda da tabela C(i,s) (abaixo). Cada processo do sistema mantém um vetor de estado com a situação (falho ou não-falho) dos demais processos. Já o algortimo Best-Effort Broadcast garante que todos os processos corretos entregam o mesmo conjunto de mensagens se a origem da mensagem estiver correta. Nesta página está disponível a implementação do programa e logs de execução do mesmo.</p>

<center>
<img src="tabelacis.jpg" alt="Simply Easy Learning" width="700">
<p style="font-family:verdana;"> A tabela C(i, s) para 8 processos.<br>O "i" representa o processo e "s" o cluster. <a style="font-family:verdana;" href="http://www.inf.ufpr.br/elias/sisdis/6aulaSisDis.pdf">Fonte</a> 
</p>
</center>

<h2 style="font-family:verdana;">Arquivos</h2>
<p style="font-family:verdana;">Abaixo os arquivos referentes a implementação do trabalho:</p>

<center>
<table style="width:50%">
  <tr>
    <th>Arquivo</th>
    <th>Descrição</th> 
  </tr>
  <tr>
    <td><a style="font-family:verdana;" href="vcube.c.txt">vcube.c</a></td>
    <td>O programa principal em c.</td>
  </tr>
  <tr>
    <td><a style="font-family:verdana;" href="http://www.inf.ufpr.br/elias/sisdis/">outros arquivos</a></td>
    <td>Arquivos utilizados: smpl.c; smpl.h; rand.c; makefile e cisj.c</td>
  </tr>
    <tr>
    <td><a style="font-family:verdana;" href="https://github.com/fontoura/token-agrupada-smpl/">Agrupa SMPL</a></td>
    <td>Utilizei essa biblioteca para agrupar argumentos do SMPL. Necessário token_agrupada.h e token_agrupada.c</td>
  </tr>
   <tr>
    <td><a style="font-family:verdana;" href="makefile.txt">Makefile</a></td>
    <td>Para compilação do programa.</td>
  </tr>
</table>
  </center>
<br>

<h2 style="font-family:verdana;">Compilalação e execução: </h2>
<p style="font-family:verdana;">Como anteriormente citado, o algoritmo VCube necessita dos valores valores da tabela C(i,s). Para obter esses valores, eu utilizei o programa <a style="font-family:verdana;" href="http://www.inf.ufpr.br/elias/sisdis/cisj.c.txt">cisj.c</a> compilado. O programa utiliza a funcão <a href="https://man7.org/linux/man-pages/man3/popen.3.html"><b>popen</b></a>, que abre um <i>pipe stream</i> para um processo que executa o programa cisj e devolve o valor que eu preciso. Portanto, para que o programa <b>vcube.c</b> funcione, é necessário compilar o programa <b>cisj.c</b> da seguinte forma:</p>

<table style="width:50%">
  <tr>
    <td><b>$</b> gcc cisj.c -o cisj</td>
  </tr>
</table>
<br>
<p style="font-family:verdana;">Depois da compilação acima, o programa pode ser compilado através do comando makefile:</p>
<table style="width:50%">
  <tr>
    <td><b>$</b> makefile</td>
  </tr>
</table>

<p style="font-family:verdana;">Para modificar o intervalo de testes, deve-se modificar a constante <b>TEST_INTERVAL</b>. Da mesma forma, para alterar o tempo de execução máximo do programa, deve-se modificar a constante <b>MAX_TIME</b>. Por fim, a constante <b>MSG_TRAVEL_TIME</b> define quantas unidades de tempo demoram para uma mensagem enviada por um processo demora para chegar no destino. Levando em consideração ser um sistema <i>fully conected</i>, decidi fazer o tempo de viagem constate. <br>Se modificações forem feitas, o programa deve ser compilado novamente. Já as falhas e recuperações devem ser feitas através da linha de comando. Também existe um modo aleatório. Para executar o programa, você deve digitar na linha de comando:</p>
<table style="width:50%">
  <tr>
    <td><b>Modo padrão</b></td>
  </tr>
   <tr> <td><b>$</b> ./vcube <"processo fonte"> <"tempo inicio broadcast"> <"nº total de nodos"> <b>-l</b> <"nodo falho 1"> <"tempo falha nodo1"> <"nodo falho n"> <"tempo falha nodo n"> </td></tr>
</table> <br>

<table style="width:50%">
  <tr>
    <td><b>Modo aleatório</b></td>
  </tr>
   <tr> <td><b>$</b> ./vcube <'processo fonte'> <'tempo inicio broadcast'> <'nº total de nodos'> <b>-a</b> <'nº de nodos que falharão'> <'semente'></td></tr>
</table> <br>


<h3 style="font-family:verdana;">Definições</h3>
<p style="font-family:verdana;">O programa possui definições de constantes para valores que representam {TEST, FAULT, RECOVERY, BEBCAST, RECIEVE, FAILED}. Essas definições são utilizadas para dar mais legibilidade na simulação. Outras definições são o tempo máximo de execução do programa e o intervalo de testes. O intervalo de testes está especificado em cada log.
  <br>O <b>tipo processo</b> criado para essa simulação contém: id, que é o identificador da facility do SMPL; state, que é o vetor de estados dos demais processos. Um vetor de inteiros igual o state, chamado pendingACK. Nesse vetor é guardado o id da mensagem que aguarda ACK de i, na posição do processo que i aguarda ACK. O valor s que representava o cluster atual do processo foi removido TipoProcesso devido a modidicação do VCube (ver abaixo).
  <br> O <b>tipo mensagem</b> possui id, origem, tipo, remetende e um ponteiro para a próxima mensagem. Descobri dolorosamente (figurativamente) que o SMPL não deixa você enviar um ponteiro através do schedule e portanto a solução que eu encotrei foi criar uma lista de mensagens e enviar o id delas para o evento.

</p>

<h3 style="font-family:verdana;">Funções</h3>
<p style="font-family:verdana;">As seguintes funções foram criadas para auxiliar a implementação do vcube e do BEBCast:<br><b>call_cisj:</b> Como explicado acima, essa função chama o programa externo cisj e retorna o valor o j-ésimo valor da tabela c(i,s) para ser utilizado nos teste.<br>
<b>pow_int:</b> Implementação simples da potenciação apenas com números inteiros. A função pow() da biblioteca math.c trabalha com double, então preferi criar a minha para simplificar.
<br><b>cluster(i,j):</b> Retorna o cluster de j no qual i pertence.
<br><b>ff_neighbour(i, s):</b> Com base no vetor state passado como parâmetro e utilizando a função call_cisj, retorna o primeiro vizinho de <b>i</b> no cluster <b>s</b> não-falho.
<br><b>concatenate:</b> Concatena dois inteiros. Usei para montar a ID da mensagem.
<br><b>getMsg:</b> Retorna um ponteiro para a mensagem correspondente a um ID.
<br><b>newMsg:</b> Aloca nova mensagem.
<br><b>sendMsg:</b> Faz o envio da mensagem, em outras palavras, programa o recebimento.
<br><b>recieveMsg:</b> Separa dois tokens.
<br><b>freeMsg:</b> Libera uma mensagem corrigindo a lista de mensagens.
<br><b>vazio:</b> Verifica se o pending ACK está vazio.
<br><b>correto:</b> Retorna 1 para processo correto e 0 para processo incorreto.
</p>

<h3 style="font-family:verdana;">Versão 1 do VCUBE</h3>
<p style="font-family:verdana;">Na versão 1 do VCUBE, primeiro é calculado o <i>s máximo</i> que representa o valor máximo que o s de cada processo vai ir. Cada rodada consiste em um cluster, este é incrementado ao começo de cada rodada. Durante a rodada, o programa chama a função c(i,s) que devolve o próximo que deve ser testado. Se o testado for correto, a iteração quebra e o proximo processo vai testar. Caso o processo esteja falho, ele vai testar o próximo valor que a função c(i,s) retornar. Se todos do cluster estiverem falhos, é o fim da rodada para este processo. Ao encontrar um processo correto, o processo copia os valores do vetor state do testado que não testou e estão no cluster atual.</p>
<h4 style="font-family:verdana;">Modificação</h3>
<p style="font-family:verdana;">Para a implementação desse trabalho, foi solicitado pelo professor duas mudanças no algoritmo:</p>
 <ul>
  <li>Agora, os processos testam todos os logN clusters em todos os intervalos de teste.</li>
  <li>Ao testar um processo sem falha o testador obtém todas as "novidades" do testado (não apenas do cluster do testado)</li>
</ul> 
<p style="font-family:verdana;">Essas mudanças foram feitas para que a latência que um evento leva para ser diagnosticado quando acontece um evento diminua.</p>
<p style="font-family:verdana;"><b>Inicialização:</b> Levando em conta que o principal objetivo do trabalho é a implementação do algortimo do Best-Effort Broadcast, e o VCube é mais uma base para o algoritmo, a fase de <i>warm-up</i> do VCube foi encurtada. Agora, ao invés dos processos inicializarem com um valor desconhecido (-1), todos os processos são inicializados como corretos (0).</p>

<h4 style="font-family:verdana;">Diagnóstico</h4>
<p style="font-family:verdana;">Os programas funciona basicamente como se tivesse dois modos: modo diagnóstico em andamento e modo diagnóstico desabilitado. No início de cada programa o modo diagnostico está sempre desabilitado. O modo diagnóstico entra em andamento sempre que há uma requisição de FALHA ou RECUPERAÇÃO, através de uma variávlç booleana. Os testes efetuados e rodadas que se passaram no modo diagnóstico são salvas em contadores. Também é salvo o processo de que se trata o diagnóstico. Apenas um diagnóstico pode acontecer por vez. O primeiro processo que "descobrir" que o processo mudou, vai ter o valor state do processo em diagnóstico salvo. Quando todos os processos (exceto processos falhos e o processo que se trata o diagnóstico) tiverem o mesmo valor nos seus vetores state, o evento foi diagnosticado e uma mensagem será impressa na tela.</p>
<br>

<h3 style="font-family:verdana;">BEBCast</h3>
<p style="font-family:verdana;">O algoritmo do Best-Effort Broadcast tem como premissa, que se os processos x e z são corretos e x faz o BEBcast de uma mensagem msg, então z eventualmente entrega msg. Se x falhar não tem mais obrigação de enviar a mensagem. <br> O espalhamento de uma mensagem ocorre como na imagem a abaixo. Um processo p vai enviar uma mensagem para um processo i correto de cada cluster, com base na tabela C(i,s) utilizando VCube.</p>

<center>
<img src="bebcast.png" alt="Simply Easy Learning" width="700">
<p style="font-family:verdana;"> Algoritmo de Best-Effort Broadcast sobre VCube para 8 processos.<br>O "i" representa o processo e "s" o cluster. <a style="font-family:verdana;" href="https://www.inf.ufpr.br/elias/sisdis/13aulaSisDisRADTP3.pdf">Fonte</a> 
</p>
</center>

<p style="font-family:verdana;">Para esse trabalho eu tive que criar uma estrutura "msg_list" para guardar todas as mensagens do sistema. Para acessar uma mensagem basta fornecer o ID para a funçao getMsg. <br> Logo no início é escalonado o evento BEBCAST, no qual o processo irá mandar as mensagens para cada processo correto de cada cluster. Cada processo ao receber, verifica qual cluster s corresponde o remetente da mensagem. Se for do menor cluster possível o processo responderá com um ACK para o remetente. Se não, guarda o id da mensage que recebeu na posição v do vetor pendingACK, sendo v o primeiro vizinho do cluster correto.<br> Para enviar uma mensagem, eu faço um escalonamento (schedule) para outro evento, REVIECE. <br> Ao receber uma mensagem, o processo vai verificar se essa mensagem é um ACK ou uma mensagem do broadcast. Se for uma mensagem fará o descrito anteriormente, se for um ACK, verifica no seu vetor e recupera a mensagem que guardou anteriormente. Nela ele consegue ter acesso ao destinatário original da mensagem para, verificar se ainda está correto e retornar um ACK, assim que seu pendingACK esteja vazio. <br>Por último, existe o evento FAILED. Um processo chama o evento quando testa um processo errado pela primeira vez ou recebe a informação (copiando o vetor state de um processo correto). Nesse evento, o processo verifica se tem algum ACK pendente desse processo falho. Se tiver ACK pendente, remove da lista e eviará uma mensagem para outro vizinho não falho do mesmo cluster que o processo falho era. Se não tiver ACK pendente, vai verificar se é o processo de origem ou o remetente de alguma mensagem. Se for, esse processo vai limpar seu vetor de ACKs pendentes.</p>

<p style="font-family:verdana;">A função delivery, presente no algoritmo original não foi implementada, por se tratar de uma simulação em "ambiente perfeito", no qual as mensagens não se perdem.</p>

<h2 style="font-family:verdana;">Logs</h2>

<center> <b>
<a style="font-family:verdana;" href="log1.html">Log 1</a>
<a style="font-family:verdana;" href="log2.html">Log 2</a>
<a style="font-family:verdana;" href="log3.html">Log 3</a>
<a style="font-family:verdana;" href="log4.html">Log 4</a>
<a style="font-family:verdana;" href="log5.html">Log 5</a>
<a style="font-family:verdana;" href="log6.html">Log 6</a>
<a style="font-family:verdana;" href="log7.html">Log 7</a>
<a style="font-family:verdana;" href="log8.html">Log 8</a>
<a style="font-family:verdana;" href="log9.html">Log 9</a>
<br> </b>

<p style="font-family:verdana;"><b>Última modificação:</b> 19/03/2021</p>

</center>
</body>
</html>
